The first step to help us understand how Serial Collector works is to understand the GC log messages generated from the Serial Collector.

java -Xms2m -Xmx64m -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps GarbageCollection






Step/TotalMemory/FreeMemory/UsedMemory:

0.102: [GC (Allocation Failure)
      0.102: [DefNew: 649K->64K(960K), 0.0008674 secs]
      649K->505K(1984K), 0.0009833 secs]


1   2031616   697016   1334600


 We got our first GC log message from the Serial Collector at 0.102 seconds after the application have started. Here are explanations for every components of the log message:

"0.102:" - Timestamp in seconds relative to the JVM start time.

"[GC (Allocation Failure) ...]" - Header of the GC (Garbage Collection) message with the reason code "Allocation Failure" for the GC. So you can read this example as "A GC is performed because of Allocation Failure."
"0.102: [DefNew: 649K->64K(960K), 0.0008674 secs]" - Young Generation GC record with the timestamp in seconds relative the JVM start time, the total object size in the Young Generation before GC, the total object size after GC, and the current total memory size and time spent on the GC. So you can read this example as "A Young Generation GC was performed at 0.102 seconds since the JVM started. It released 585K of space by removing dead objects and promoting older objects to the Tenured Generation, reduced the total object size from 649K to 64K in the Young Generation, and took 0.0008674 seconds. The total memory size of the Young Generation was 960K at the time of the GC." "DefNew (Default New)" is the internal name of the Serial Collector.

"... 649K->505K(1984K), ..." - GC summary at the Heap level, including both Young Generation and Tenured Generation, with the total object size in the Heap before GC, the total object size after GC, and the current total memory size of the Heap. So you can read this example as "The GC released 144 of dead objects, reduced the total object size from 649K to 505K in the Heap. The total memory size of the Heap was 1984K at the time of the GC."

"... 0.0009833 secs]" - Total time in seconds spent on the entire GC operation, including Young Generation GC, Tenured Generation GC and Method Area GC. So you can read this example as "0.0009833 seconds spent on the entire GC operation."
"[Times: user=0.00 sys=0.00, real=0.00 secs]" - CPU time report of the entire GC operation with CPU time spent on the JVM (user), CPU time spent on the OS kernel (system), and elapsed time of the GC. Note that CPU time could be higher than elapsed time, if multiple CPUs were used. All times are in unit of seconds and truncated with 2 decimal points. So you can read this example as "0.00 CPU seconds spent on the JVM, 0.00 CPU seconds spent on OS kernel. The entire GC took 0.00 seconds."
